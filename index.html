<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>View non-printable unicode characters</title>
    <style>
      body {
        font-family: Helvetica, Arial, sans-serif;
        background-color: #eeeeee;
      }
      div.main {
        background-color: white;
        border-radius: 10px;
        border: 2px solid #666666;
        box-shadow: 5px 5px 5px #999999;
        padding: 2.4em 3em;
        margin: 0 auto;
        max-width: 1000px;
      }
      div.output {
        margin: 3em 0;
        border: 1px solid #666666;
        padding: 0.4em 0.2em;
        font-family: Courier New, Courier, monospaced;
        cursor: default;
      }
      div.output span.symbol {
        color: white;
        background-color: #999999;
        padding: 0 2px;
        margin: 0 2px;
      }
      div.output span.hex {
        color: black;
        background-color: #9999ff;
        padding: 0 2px;
        margin: 0 2px;
      }
      span.S2Tooltip.anchor {
        white-space: nowrap;
      }
      span.S2Tooltip.container {
        position: absolute;
        z-index: 999;
        left: -99999px;
        top: -99999px;
      }
      span.S2Tooltip.anchor:hover {
        background-color: #ff9999;
      }
      span.S2Tooltip.anchor:hover + span.S2Tooltip.container {
        left: auto;
        top: auto;
      }
      span.S2Tooltip.tiptext {
        position: absolute;
        left: -2em;
        top: 1.5em;
        padding: 0.5em 0.8em 0.7em 0.8em;
        color: black;
        background-color: #ddddff;
        border: 1px solid #9999ff;
        font-weight: normal;
        text-align: left;
        display: block;
        text-indent: 0;
      }
    </style>
  </head>
  <body>
    <div class="main">
      <h1>View non-printable unicode characters</h1>
      <p>
        Online tool to display non-printable characters that may be hidden in
        copy&amp;pasted strings.
      </p>

      <div style="margin-top: 3em">Please paste the string here:</div>
      <div>
        <textarea
          name="s"
          id="text-input"
          rows="8"
          cols="40"
          style="width: 100%; box-sizing: border-box"
          dir="auto"
        ></textarea>
      </div>
      <div style="margin: 1em 0;">
        <button id="export-btn" style="background-color: #237625; color: white; padding: 10px 20px; border: none; border-radius: 5px; cursor: pointer; font-size: 14px;">
          Export Analysis to TXT
        </button>
      </div>
      <div id="output-container"></div>
      <div id="info-container" style="margin: -2.5em 0 4em 0"></div>

      <h2>Helpful Sites for Details on UTF Characters</h2>
      <ul>
        <li>
          <a href="https://www.branah.com/unicode-converter" target="_blank"
            >Branah.com Unicode Converter</a
          >
        </li>
        <li>
          <a
            href="http://www.fileformat.info/info/unicode/char/search.htm"
            target="_blank"
            >FileFormat.Info</a
          >
        </li>
        <li>
          <a
            href="http://utf8-chartable.de/unicode-utf8-table.pl"
            target="_blank"
            >utf8-chartable.de</a
          >
        </li>
      </ul>

      <h2>Privacy Note</h2>
      <p>
        This web page (tool) does not store any information about you (no
        cookies, no IP logging) and it does not store any of the text that is
        written or pasted into the box above.
      </p>
      <h2>Source Code</h2>
      <p>
        This tool is open source and available on
        <a href="https://github.com/BurninLeo/see-non-printable-characters"
          >GitHub</a
        >.
      </p>
    </div>
    <script>
      class ViewChars {
        static htmlChar(c) {
          const n = c.codePointAt(0);
          let desc;
          let hex;

          if (n < 0x10000) {
            desc = `&amp;#${n};<br>\\u${n
              .toString(16)
              .toUpperCase()
              .padStart(4, "0")}`;
            hex = `U+${n.toString(16).toUpperCase().padStart(4, "0")}`;
          } else {
            desc = `&amp;#${n};<br>\\u{${n.toString(16).toUpperCase()}}`;
            hex = `U+${n.toString(16).toUpperCase()}`;
          }

          let symbol;
          if (c === "\r") {
            symbol = '<span class="symbol S2Tooltip anchor">CR</span>';
          } else if (c === "\n") {
            symbol = '<span class="symbol S2Tooltip anchor">LF</span>';
          } else if (c === "\t") {
            symbol = '<span class="symbol S2Tooltip anchor">⟶</span>&#8203;';
          } else if (c === " ") {
            symbol = '<span class="white S2Tooltip anchor">·</span>&#8203;';
          } else {
            if (/^[\p{L}\p{M}\p{N}\p{P}\p{S}]$/u.test(c)) {
              symbol = `<span class="S2Tooltip anchor">${c}</span>`;
            } else {
              symbol = `<span class="hex S2Tooltip anchor">${hex}</span>`;
            }
          }

          return `${symbol}<span class="S2Tooltip container"><span class="S2Tooltip tiptext rounded shadow">${desc}</span></span>`;
        }

        static text2html(s) {
          let html = '<div class="output" dir="auto">';
          let nlc = 0;

          for (const c of s) {
            if (c === "\r") {
              if (nlc === 0) {
                nlc = 1;
                html += this.htmlChar(c);
              } else if (nlc === 1) {
                html += "<br>" + this.htmlChar(c);
                nlc = 1;
              } else if (nlc === 2) {
                html += this.htmlChar(c) + "<br>";
                nlc = 0;
              }
            } else if (c === "\n") {
              if (nlc === 0) {
                nlc = 2;
                html += this.htmlChar(c);
              } else if (nlc === 2) {
                html += "<br>" + this.htmlChar(c);
                nlc = 2;
              } else if (nlc === 1) {
                html += this.htmlChar(c) + "<br>";
                nlc = 0;
              }
            } else {
              if (nlc !== 0) {
                html += "<br>";
                nlc = 0;
              }
              html += this.htmlChar(c);
            }
          }

          return html + "</div>";
        }

        static processText() {
          const textInput = document.getElementById("text-input");
          const outputContainer = document.getElementById("output-container");
          const infoContainer = document.getElementById("info-container");

          const s = textInput.value;

          outputContainer.innerHTML = this.text2html(s);

          const charCount = s.length;
          const byteCount = new TextEncoder().encode(s).length;
          infoContainer.innerHTML = `${charCount} characters, ${byteCount} bytes`;
        }

        static exportAnalysis() {
          const textInput = document.getElementById("text-input");
          const s = textInput.value;
          
          if (!s) {
            alert("Please enter some text to export analysis.");
            return;
          }

          const timestamp = new Date().toISOString().replace('T', ' ').substr(0, 19);
          const charCount = s.length;
          
          let report = `=================================================\n`;
          report += `Unicode Character Analysis Report\n`;
          report += `Generated: ${timestamp}\n`;
          report += `Tool: View non-printable unicode characters\n`;
          report += `=================================================\n\n`;
          
          report += `SUMMARY:\n`;
          report += `- Total characters: ${charCount}\n\n`;
          
          const nonPrintableChars = [];
          const specialChars = [];
          const regularChars = [];
          
          for (let i = 0; i < s.length; i++) {
            const c = s[i];
            const codePoint = c.codePointAt(0);
            const hex = codePoint < 0x10000 
              ? `U+${codePoint.toString(16).toUpperCase().padStart(4, "0")}`
              : `U+${codePoint.toString(16).toUpperCase()}`;
            
            const charInfo = {
              char: c,
              position: i + 1,
              codePoint: codePoint,
              hex: hex,
              description: this.getCharDescription(c, codePoint)
            };
            
            if (this.isNonPrintable(c, codePoint)) {
              nonPrintableChars.push(charInfo);
            } else if (this.isSpecialChar(c, codePoint)) {
              specialChars.push(charInfo);
            } else {
              regularChars.push(charInfo);
            }
          }
          
          if (nonPrintableChars.length > 0) {
            report += `NON-PRINTABLE/INVISIBLE CHARACTERS FOUND (${nonPrintableChars.length}):\n`;
            report += `${'='.repeat(50)}\n`;
            nonPrintableChars.forEach(char => {
              report += `Position ${char.position}: ${char.description} (${char.hex})\n`;
            });
            report += `\n`;
          }
          
          if (specialChars.length > 0) {
            report += `SPECIAL CHARACTERS (${specialChars.length}):\n`;
            report += `${'='.repeat(30)}\n`;
            specialChars.forEach(char => {
              report += `Position ${char.position}: "${char.char}" - ${char.description} (${char.hex})\n`;
            });
            report += `\n`;
          }
          
          report += `FULL CHARACTER BREAKDOWN:\n`;
          report += `${'='.repeat(30)}\n`;
          for (let i = 0; i < s.length; i++) {
            const c = s[i];
            const codePoint = c.codePointAt(0);
            const hex = codePoint < 0x10000 
              ? `U+${codePoint.toString(16).toUpperCase().padStart(4, "0")}`
              : `U+${codePoint.toString(16).toUpperCase()}`;
            const desc = this.getCharDescription(c, codePoint);
            
            if (c === '\n') {
              report += `${i + 1}: [LF] ${desc} (${hex})\n`;
            } else if (c === '\r') {
              report += `${i + 1}: [CR] ${desc} (${hex})\n`;
            } else if (c === '\t') {
              report += `${i + 1}: [TAB] ${desc} (${hex})\n`;
            } else if (c === ' ') {
              report += `${i + 1}: [SPACE] ${desc} (${hex})\n`;
            } else if (this.isNonPrintable(c, codePoint)) {
              report += `${i + 1}: [INVISIBLE] ${desc} (${hex})\n`;
            } else {
              report += `${i + 1}: "${c}" ${desc} (${hex})\n`;
            }
          }
          
          report += `\n${'='.repeat(50)}\n`;
          report += `End of Analysis Report\n`;
          
          const blob = new Blob([report], { type: 'text/plain;charset=utf-8' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = `unicode-analysis-${timestamp.replace(/[: ]/g, '-')}.txt`;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
        }
        
        static getCharDescription(c, codePoint) {
          if (c === '\r') return 'Carriage Return';
          if (c === '\n') return 'Line Feed';
          if (c === '\t') return 'Horizontal Tab';
          if (c === ' ') return 'Space';
          if (codePoint === 0x00A0) return 'Non-Breaking Space';
          if (codePoint === 0x200B) return 'Zero Width Space';
          if (codePoint === 0x200C) return 'Zero Width Non-Joiner';
          if (codePoint === 0x200D) return 'Zero Width Joiner';
          if (codePoint === 0xFEFF) return 'Zero Width No-Break Space (BOM)';
          if (codePoint === 0x2026) return 'Horizontal Ellipsis';
          if (codePoint >= 0x2000 && codePoint <= 0x200F) return 'Unicode Space/Format Character';
          if (codePoint >= 0x202A && codePoint <= 0x202E) return 'Bidirectional Format Character';
          if (codePoint >= 0x2060 && codePoint <= 0x206F) return 'Unicode Format Character';
          
          if (codePoint < 32 || codePoint === 127) return 'Control Character';
          if (codePoint >= 0x80 && codePoint <= 0x9F) return 'C1 Control Character';
          
          return 'Regular Character';
        }
        
        static isNonPrintable(c, codePoint) {
          if (codePoint < 32 || codePoint === 127) return true;
          if (codePoint >= 0x80 && codePoint <= 0x9F) return true;
          
          if (codePoint === 0x00A0) return true;
          if (codePoint >= 0x200B && codePoint <= 0x200F) return true;
          if (codePoint >= 0x202A && codePoint <= 0x202E) return true;
          if (codePoint >= 0x2060 && codePoint <= 0x206F) return true;
          if (codePoint === 0xFEFF) return true;
          
          return false;
        }
        
        static isSpecialChar(c, codePoint) {
          if (c === ' ' || c === '\t' || c === '\n' || c === '\r') return true;
          if (codePoint === 0x2026) return true;
          return false;
        }
      }

      document.addEventListener("DOMContentLoaded", () => {
        const textInput = document.getElementById("text-input");
        const exportBtn = document.getElementById("export-btn");

        textInput.value =
          "See\u00A0what's hidden in your string\u2026\tor be\u200Bhind\uFEFF";
        ViewChars.processText();

        textInput.addEventListener("input", () => {
          ViewChars.processText();
        });

        exportBtn.addEventListener("click", () => {
          ViewChars.exportAnalysis();
        });
      });
    </script>
  </body>
</html>
